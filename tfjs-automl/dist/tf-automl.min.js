/**
 * @license
 * Copyright 2024 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2024 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-converter"),require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-converter","@tensorflow/tfjs-core"],e):e(((t="undefined"!=typeof globalThis?globalThis:t||self).tf=t.tf||{},t.tf.automl=t.tf.automl||{}),t.tf,t.tf)}(this,(function(t,e,o){"use strict";
/**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */function s(t){return t instanceof o.Tensor?t:o.browser.fromPixels(t)}async function r(t){const e=t.lastIndexOf("/"),s=`${e>=0?t.slice(0,e+1):""}dict.txt`,r=await o.util.fetch(s);return(await r.text()).trim().split("\n")}
/**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */const n=[224,224];class i{constructor(t,e){this.graphModel=t,this.dictionary=e}async classify(t,e){e=function(t){null==(t=t||{}).centerCrop&&(t.centerCrop=!0);return t}(e);const s=o.tidy((()=>{const o=this.preprocess(t,e);return this.graphModel.predict(o)})),r=await s.data();s.dispose();return Array.from(r).map(((t,e)=>({label:this.dictionary[e],prob:t})))}preprocess(t,e){const r=s(t),i=e.centerCrop?function(t){return o.tidy((()=>{const[e,s]=t.shape.slice(0,2);let r=0,i=0;e>s?r=(e-s)/2:i=(s-e)/2;const a=Math.min(s,e),c=[[r/e,i/s,(r+a)/e,(i+a)/s]],l=[0];return o.image.cropAndResize(o.expandDims(o.cast(t,"float32")),c,l,n)}))}
/**
   * @license
   * Copyright 2019 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */(r):o.expandDims(o.image.resizeBilinear(r,n));return o.sub(o.div(i,127.5),1)}}const a=["Postprocessor/convert_scores","Postprocessor/Decode/transpose_1"];class c{constructor(t,e){this.graphModel=t,this.dictionary=e}async detect(t,e){e=function(t){null==(t=t||{}).topk&&(t.topk=20);null==t.iou&&(t.iou=.5);null==t.score&&(t.score=.5);return t}(e);const s=o.tidy((()=>this.preprocess(t,e))),[r,n]=[s.shape[1],s.shape[2]],i={};i.ToFloat=s;const[c,l]=await this.graphModel.executeAsync(i,a),[,f,u]=c.shape,[p,d]=await Promise.all([c.data(),l.data()]),{boxScores:h,boxLabels:m}=function(t,e,o){const s=[],r=[];for(let n=0;n<e;n++){let e=Number.MIN_VALUE,i=-1;for(let s=0;s<o;s++){const r=n*o+s;t[r]>e&&(e=t[r],i=s)}s[n]=e,r[n]=i}return{boxScores:s,boxLabels:r}}(p,f,u),y=await o.image.nonMaxSuppressionAsync(l,h,e.topk,e.iou,e.score),b=await y.data();o.dispose([s,c,l,y]);const w=function(t,e,o,s,r,n,i){const a=[],c=4;for(let l=0;l<n.length;l++){const f=n[l],[u,p,d,h]=Array.from(o.slice(f*c,f*c+c));a.push({box:{left:p*t,top:u*e,width:(h-p)*t,height:(d-u)*e},label:i[r[f]],score:s[f]})}return a}
/** @license See the LICENSE file. */(n,r,d,h,m,b,this.dictionary);return w}preprocess(t,e){return o.cast(o.expandDims(s(t)),"float32")}}t.ImageClassificationModel=i,t.ObjectDetectionModel=c,t.loadImageClassification=async function(t){const[o,s]=await Promise.all([e.loadGraphModel(t),r(t)]);return new i(o,s)},t.loadObjectDetection=async function(t){const[o,s]=await Promise.all([e.loadGraphModel(t),r(t)]);return new c(o,s)},t.version="1.2.0"}));
//# sourceMappingURL=tf-automl.min.js.map
